import nodi.*;
import java.util.ArrayList;
terminal MAIN, SEMI, COMMA, PIPE, VAR, STRING, BOOL,INTEGER,REAL, UMINUS,
CHAR, VOID, DEF, OUT, FOR, IF,THEN, ELSE, WHILE, TO, LOOP, READ, WRITE, WRITELN, LPAR, RPAR, LBRACK, RBRACK, COLON, ASSIGN, RETURN,  TRUE, FALSE, PLUS, MINUS, TIMES, DIV, POW, STR_CONCAT, EQ, NE, LT, LE, GT, GE, AND, OR, NOT ;
terminal String ID, STRING_CONST;
terminal  Integer INTEGER_CONST;

terminal float REAL_CONST;
terminal Character CHAR_CONST;


nonterminal Program, DeclList, MainFunDecl,
 VarDecl,FunDecl, Type, IdInitList,IdInitObblList,Expr,Const,  ParamDeclList,TypeOrVoid, Body,
 VarDeclList, StatList,NonEmptyParamDeclList,ParDecl, IdList, Stat, IfStat,ForStat,ReadStat,WriteStat,AssignStat,
 WhileStat,FunCall,Else,ExprList;
// The value associated to a Circuit1 and a Series block is the resistance; for
// a Parallel block it is the conductance.
// Now the grammar itself

precedence nonassoc FOR, IF, WHILE, LPAR, RBRACK, RETURN, ID;
precedence left OR;
precedence left AND;
precedence right NOT;
precedence left GT,GE;
precedence left  EQ, NE,LT, LE;
precedence left STR_CONCAT;
precedence left PLUS,MINUS;
precedence left DIV, TIMES;
precedence right POW;
precedence left UMINUS;


Program ::= DeclList MainFunDecl DeclList {:RESULT = {new ProgramRoot("Program", };:};

            DeclList ::= VarDecl DeclList
            | FunDecl DeclList
            | /* empty */;

            MainFunDecl ::= MAIN FunDecl
            ;

            VarDecl ::= Type IdInitList SEMI
            	| VAR IdInitObblList SEMI;

            Type ::=
             INTEGER  {:RESULT = "INTEGER";:}
            | BOOL       {:RESULT = "BOOL";:}
            | REAL       {:RESULT = "REAL";:}
            | STRING        {:RESULT = "STRING";:}
            | CHAR       {:RESULT = "CHAR";:}
            ;

            IdInitList ::= ID
            	| IdInitList COMMA ID
            	| ID ASSIGN Expr
            	| IdInitList COMMA ID ASSIGN Expr;

            IdInitObblList ::= ID ASSIGN Const
            	| IdInitObblList COMMA ID ASSIGN Const;

            Const ::= INTEGER_CONST  {:RESULT = "INTEGER_CONST";:}
            | REAL_CONST             {:RESULT = "REAL_CONST";:}
            | TRUE                   {:RESULT = "TRUE";:}
            | FALSE                  {:RESULT = "FALSE";:}
            | STRING_CONST           {:RESULT = "STRING_CONST";:}
            | CHAR_CONST             {:RESULT = "CHAR_CONST";:}
            ;

            FunDecl ::= DEF ID LPAR ParamDeclList RPAR COLON TypeOrVoid Body;

            Body ::= LBRACK VarDeclList StatList RBRACK;

            ParamDeclList ::= /*empty */
            	| NonEmptyParamDeclList;

            NonEmptyParamDeclList ::= ParDecl
            	| NonEmptyParamDeclList PIPE ParDecl;

            ParDecl ::= Type IdList
            	| OUT Type IdList;

            TypeOrVoid ::= Type
            | VOID;

            VarDeclList ::=/* empty */
            	| VarDecl VarDeclList;

            StatList ::= Stat
            	 | StatList Stat ;


            Stat ::= IfStat
            	| ForStat
            	| ReadStat SEMI
            	| WriteStat SEMI
            	| AssignStat SEMI
                    | WhileStat
            	| FunCall SEMI
            	| RETURN Expr SEMI
            	| RETURN SEMI
            	| /* empty */;

            IfStat ::= IF Expr THEN Body Else

            ;

            Else ::= /* empty */
            	| ELSE Body
            	;

            WhileStat ::= WHILE Expr LOOP Body
            ;

            ForStat ::= FOR ID ASSIGN INTEGER_CONST TO INTEGER_CONST LOOP Body
            ;

            ReadStat ::= IdList:idList READ STRING_CONST:val  {:RESULT = new ReadStat("ReadOp",(ArrayList<IdVal>) idList, val);:}
            	|  IdList:idList READ      {:RESULT = new ReadStat("ReadOp",(ArrayList<IdVal>) idList);:}
            	;

      //      IdList ::= ID:id   {: ArrayList<IdVal> list = new ArrayList<IdVal>(); list.add(new IdVal(id)); RESULT = list;:}
      //      	| IdList:idList COMMA ID:id {:((ArrayList<IdVal>)idList).add(new IdVal(id)); RESULT = idList;:};

            WriteStat ::=  LPAR ExprList:exprList RPAR WRITE {: RESULT = new WriteStat ("WriteOp",(ArrayList<ExprNode>) exprList);:}
            |  LPAR ExprList:exprList RPAR WRITELN {:RESULT = new WriteStat("WritelnOp",(ArrayList<ExprNode>) exprList);:};




             AssignStat ::=  IdList:idList ASSIGN ExprList:exprList {: RESULT = new AssignStat("AssignOp",(ArrayList<IdVal>)idList,(ArrayList<ExprNode>)exprList); :};

       //     FunCall ::= ID:id LPAR ExprList:exprlist RPAR {: RESULT = new FuncallNode("FuncallOp", new IdVal(id), (ArrayList<ExprNode>)exprlist); :}
       //    	| ID:id LPAR RPAR               {: RESULT = new FuncallNode("FuncallOp", new IdVal(id)); :}
       //     ;
       //     ExprList ::= Expr:expr                {: ArrayList<ExprNode> list = new ArrayList<ExprNode>(); list.add(0, (ExprNode)expr); RESULT = list;:}
       //     	| Expr:expr COMMA ExprList:exprlist   {:((ArrayList<ExprNode>)exprlist).add(0, (ExprNode)expr); RESULT = exprList;:};

            Expr ::= TRUE                  {: RESULT = new ExprNode("TRUE", new BoolConst(true)); :}
            	| FALSE                    {: RESULT = new ExprNode("FALSE", new BoolConst(false)); :}
            	| INTEGER_CONST:val        {: RESULT = new ExprNode("INTEGER_CONST", new IntegerConst(val)); :}
            	| REAL_CONST:val           {: RESULT = new ExprNode("REAL_CONST", new RealConst(val)); :}
            	| STRING_CONST:val         {: RESULT = new ExprNode("STRING_CONST", new StringConst(val)); :}
            	| CHAR_CONST:val           {: RESULT = new ExprNode("CHAR_CONST", new CharConst(val)); :}
            	| ID:val                   {: RESULT = new ExprNode("ID", new IdVal(val)); :}
            //	| FunCall:val              {: RESULT = new ExprNode("FuncallOp", new FuncallNode(val)); :}
            //	| Expr:e1  PLUS Expr:e2          {: RESULT = new ExprNode("AddOp", (Node)e1), (Node)e2; :}
            //	| Expr:e1  MINUS Expr:e2         {: RESULT = new ExprNode("MinusOp", (Node)e1), (Node)e2; :}
            //	| Expr:e1  TIMES Expr:e2         {: RESULT = new ExprNode("MulOp", (Node)e1), (Node)e2; :}
            //	| Expr:e1  DIV Expr:e2           {: RESULT = new ExprNode("DivOp", (Node)e1), (Node)e2; :}
            //	| Expr:e1  AND Expr:e2           {: RESULT = new ExprNode("AndOp", (Node)e1), (Node)e2; :}
            //	| Expr:e1 POW Expr:e2            {: RESULT = new ExprNode("PowOp", (Node)e1), (Node)e2; :}
            //	| Expr:e1 STR_CONCAT Expr:e2     {: RESULT = new ExprNode("StrConcatOp", (Node)e1), (Node)e2; :}
            //	| Expr:e1  OR Expr:e2            {: RESULT = new ExprNode("OrOp", (Node)e1), (Node)e2; :}
            //	| Expr:e1  GT Expr:e2            {: RESULT = new ExprNode("GtOp", (Node)e1), (Node)e2; :}
            //	| Expr:e1  GE Expr:e2            {: RESULT = new ExprNode("GeOp", (Node)e1), (Node)e2; :}
            //	| Expr:e1  LT Expr:e2            {: RESULT = new ExprNode("LtOp", (Node)e1), (Node)e2; :}
            //	| Expr:e1  LE Expr:e2            {: RESULT = new ExprNode("LeOp", (Node)e1), (Node)e2; :}
            //	| Expr:e1  EQ Expr:e2            {: RESULT = new ExprNode("EqOp", (Node)e1), (Node)e2; :}
            //	| Expr:e1  NE Expr:e2            {: RESULT = new ExprNode("NeOp", (Node)e1), (Node)e2; :}
            //	| MINUS Expr:e1               {: RESULT = new ExprNode("UminusOp", (Node)e1); :}  %prec UMINUS
            //	| NOT Expr:e1                 {: RESULT = new ExprNode("NotOp", (Node)e1); :}
            //	| LPAR Expr:e1 RPAR           {: RESULT = new ExprNode("InparOp", (Node)e1); :}
;
