
terminal MAIN, SEMI, COMMA, PIPE, VAR, STRING, BOOL,INTEGER,REAL, UMINUS,
CHAR, VOID, DEF, OUT, FOR, IF,THEN, ELSE, WHILE, TO, LOOP, READ, WRITE, WRITELN, LPAR, RPAR, LBRACK, RBRACK, COLON, ASSIGN, RETURN, ID,  REAL_CONST, CHAR_CONST, TRUE, FALSE, PLUS, MINUS, TIMES, DIV, POW, STR_CONCAT, EQ, NE, LT, LE, GT, GE, AND, OR, NOT ;
terminal String STRING_CONST;
terminal  INTEGER_CONST;

nonterminal Program, DeclList, MainFunDecl,
 VarDecl,FunDecl, Type, IdInitList,IdInitObblList,Expr,Const,  ParamDeclList,TypeOrVoid, Body,
 VarDeclList, StatList,NonEmptyParamDeclList,ParDecl, IdList, Stat, IfStat,ForStat,ReadStat,WriteStat,AssignStat,
 WhileStat,FunCall,Else,ExprList;
// The value associated to a Circuit1 and a Series block is the resistance; for
// a Parallel block it is the conductance.
// Now the grammar itself


precedence left OR;
precedence left AND;
precedence right NOT;
precedence left GT,GE;
precedence left  EQ, NE,LT, LE;
precedence left STR_CONCAT;
precedence left PLUS,MINUS;
precedence left DIV, TIMES;
precedence right POW;
precedence left UMINUS;


Program ::= DeclList MainFunDecl DeclList;

            DeclList ::= VarDecl DeclList | FunDecl DeclList | /* empty */;

            MainFunDecl ::= MAIN FunDecl;

            VarDecl ::= Type IdInitList SEMI
            	| VAR IdInitObblList SEMI;

            Type ::= INTEGER | BOOL | REAL | STRING | CHAR;

            IdInitList ::= ID
            	| IdInitList COMMA ID
            	| ID ASSIGN Expr
            	| IdInitList COMMA ID ASSIGN Expr;

            IdInitObblList ::= ID ASSIGN Const
            	| IdInitObblList COMMA ID ASSIGN Const;

            Const ::= INTEGER_CONST | REAL_CONST | TRUE | FALSE | STRING_CONST | CHAR_CONST;

            FunDecl ::= DEF ID LPAR ParamDeclList RPAR COLON TypeOrVoid Body;

            Body ::= LBRACK VarDeclList StatList RBRACK;

            ParamDeclList ::= /*empty */
            	| NonEmptyParamDeclList;

            NonEmptyParamDeclList ::= ParDecl
            	| NonEmptyParamDeclList PIPE ParDecl;

            ParDecl ::= Type IdList
            	| OUT Type IdList;

            TypeOrVoid ::= Type | VOID;

            VarDeclList ::=/* empty */
            	| VarDecl VarDeclList;

            StatList ::= Stat
            	 | Stat StatList;


            Stat ::= IfStat
            	| ForStat
            	| ReadStat SEMI
            	| WriteStat SEMI
            	| AssignStat SEMI
                    | WhileStat
            	| FunCall SEMI
            	| RETURN Expr SEMI
            	| RETURN SEMI;
            	//| /* empty */;

            IfStat ::= IF Expr THEN Body Else;

            Else ::= /* empty */
            	| ELSE Body;

            WhileStat ::= WHILE Expr LOOP Body;

            ForStat ::= FOR ID ASSIGN INTEGER_CONST TO INTEGER_CONST LOOP Body;

            ReadStat ::= IdList READ STRING_CONST
            	|  IdList READ;

            IdList ::= ID
            	| IdList COMMA ID;

            WriteStat ::=  LPAR ExprList RPAR WRITE |  LPAR ExprList RPAR WRITELN;


            AssignStat ::=  IdList ASSIGN ExprList;

            FunCall ::= ID LPAR ExprList RPAR
            	| ID LPAR RPAR;

            ExprList ::= Expr
            	| Expr COMMA ExprList;

            Expr ::= TRUE                  {: RESULT = new ExprNode("TRUE", new BoolConst(true)); :}
            	| FALSE                    {: RESULT = new ExprNode("FALSE", new BoolConst(false)); :}
            	| INTEGER_CONST:val            {: RESULT = new ExprNode("INTEGER_CONST", new); :}
            	| REAL_CONST:val               {: RESULT = new ExprNode("REAL_CONST", new); :}
            	| STRING_CONST:val             {: RESULT = new ExprNode("STRING_CONST", new); :}
            	| CHAR_CONST:val               {: RESULT = new ExprNode("CHAR_CONST", new); :}
            	| ID:val                       {: RESULT = new ExprNode("ID", new); :}
            	| FunCall:val                  {: RESULT = new ExprNode("FuncallOp", new); :}
            	| Expr:e1  PLUS Expr:e2          {: RESULT = new ExprNode("AddOp", (Node)e1); :}
            	| Expr:e1  MINUS Expr:e2         {: RESULT = new ExprNode("MinusOp", (Node)e1); :}
            	| Expr:e1  TIMES Expr:e2         {: RESULT = new ExprNode("MulOp", (Node)e1); :}
            	| Expr:e1  DIV Expr:e2           {: RESULT = new ExprNode("DivOp", (Node)e1); :}
            	| Expr:e1  AND Expr:e2           {: RESULT = new ExprNode("AndOp", (Node)e1); :}
            	| Expr:e1 POW Expr:e2            {: RESULT = new ExprNode("PowOp", (Node)e1); :}
            	| Expr:e1 STR_CONCAT Expr:e2     {: RESULT = new ExprNode("StrConcatOp", (Node)e1); :}
            	| Expr:e1  OR Expr:e2            {: RESULT = new ExprNode("OrOp", (Node)e1); :}
            	| Expr:e1  GT Expr:e2            {: RESULT = new ExprNode("GtOp", (Node)e1); :}
            	| Expr:e1  GE Expr:e2            {: RESULT = new ExprNode("GeOp", (Node)e1); :}
            	| Expr:e1  LT Expr:e2            {: RESULT = new ExprNode("LtOp", (Node)e1); :}
            	| Expr:e1  LE Expr:e2            {: RESULT = new ExprNode("LeOp", (Node)e1); :}
            	| Expr:e1  EQ Expr:e2            {: RESULT = new ExprNode("EqOp", (Node)e1); :}
            	| Expr:e1  NE Expr:e2            {: RESULT = new ExprNode("NeOp", (Node)e1); :}
            	| MINUS Expr:e1               {: RESULT = new ExprNode("UminusOp", (Node)e1); :}  %prec UMINUS
            	| NOT Expr:e1                 {: RESULT = new ExprNode("NotOp", (Node)e1); :}
            	| LPAR Expr:e1 RPAR           {: RESULT = new ExprNode("InparOp", (Node)e1); :}
;